//
// pch.cpp
// Include the standard header and generate the precompiled header.
//


/*
* stribog.c
*
*  Created on: May 5, 2012
*      Author: Oleksandr Kazymyrov
*		Acknowledgments: Oleksii Shevchuk
*/
#pragma once

#include "pch.h"
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>
#include "stribog_data.h" 
#include "StateMapper.h"



void Stribog::AddModulo512(const unsigned char *a, const unsigned char *b, unsigned char *c)
{
	int i = 0, t = 0;

	for (i = 63; i >= 0; i--)
	{
		t = a[i] + b[i] + (t >> 8);
		c[i] = t & 0xFF;
	}
}

// a = N
// b = h
// c = k
void Stribog::AddXor512(const void *a, const void *b, void *c)
{
	int i = 0;
	const long long *A = 0, *B = 0;
	unsigned long long *C = 0;

	memcpy(&A, &a, sizeof(a));
	memcpy(&B, &b, sizeof(b));
	memcpy(&C, &c, sizeof(c));

	for (i = 0; i<8; i++)
	{
		C[i] = A[i] ^ B[i];
	}

	memcpy(&a, &A, sizeof(A));
	memcpy(&b, &B, sizeof(B));
	memcpy(&c, &C, sizeof(C));

}

void Stribog::S(unsigned char *state)
{
	int i = 0;

	for (i = 0; i<64; i++)
	{
		state[i] = Sbox[state[i]];
	}
}

void Stribog::L(unsigned char *state)
{
	unsigned long long v = 0;
	int i = 0, j = 0, k = 0;

	for (i = 0; i<8; i++)
	{
		v = 0;
		for (k = 0; k<8; k++)
		{
			for (j = 0; j<8; j++)
			{
				if ((state[i * 8 + k] & (1 << (7 - j))) != 0)
					v ^= A[k * 8 + j];
			}
		}
		for (k = 0; k<8; k++)
		{
			state[i * 8 + k] = (v & ((unsigned long long)0xFF << (7 - k) * 8)) >> (7 - k) * 8;
		}
	}
}

void Stribog::P(unsigned char *state)
{
	int i = 0;
	unsigned char t[64] = { 0 };

	for (i = 0; i<64; i++)
	{
		t[i] = state[Tau[i]];
	}

	memcpy(state, t, 64);
}

void Stribog::KeySchedule(unsigned char *K, int i)
{
	AddXor512(K, C[i], K);

	S(K);
	P(K);
	L(K);
}

void Stribog::E(unsigned char *K, const unsigned char *m, unsigned char *state)
{
	auto app = safe_cast<App2::App^>(App2::App::Current);

	int i = 0;

	memcpy(K, K, 64);

	AddXor512(m, K, state);

	for (i = 0; i<12; i++)
	{
		S(state);
		app->stateMapper->setValue(App2::Value::S, state, 64);
		
		P(state);

		app->stateMapper->setValue(App2::Value::P, state, 64);
		L(state);

		app->stateMapper->setValue(App2::Value::L, state, 64);


		KeySchedule(K, i);
		AddXor512(state, K, state);
	}

	app->stateMapper->setValue(App2::Value::E, K, 64);
}

void Stribog::g_N(const unsigned char *N, unsigned char *h, const unsigned char *m)
{
	unsigned char t[64], K[64];

	AddXor512(N, h, K);

	S(K);
	P(K);
	L(K);

	E(K, m, t);

	AddXor512(t, h, t);
	AddXor512(t, m, h);
}

void Stribog::hash_X(unsigned char *IV, const unsigned char *message, unsigned long long length, unsigned char *out)
{
	unsigned char v512[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00
	};
	unsigned char v0[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	unsigned char Sigma[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	unsigned char N[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	unsigned char m[64], *hash = IV;
	unsigned long long len = length;

	auto app = safe_cast<App2::App^>(App2::App::Current);

	app->stateMapper->setStep(App2::Step::STEP_1);

	app->stateMapper->setValue(App2::Value::INIT_EPSILON, Sigma, 64);
	app->stateMapper->setValue(App2::Value::INIT_H, hash, 64);
	app->stateMapper->setValue(App2::Value::INIT_N, N, 64);	

	// Stage 2
	app->stateMapper->setStep(App2::Step::STEP_2);
	int iteration = 1;

	while (len >= 512)
	{
		memcpy(m, message + len / 8 - 63 - ((len & 0x7) == 0), 64);

		g_N(N, hash, m);
		app->stateMapper->setValue(App2::Value::G_N, hash, 64);

		AddModulo512(N, v512, N);
		app->stateMapper->setValue(App2::Value::N, N, 64);

		AddModulo512(Sigma, m, Sigma);
		app->stateMapper->setValue(App2::Value::EPSILON, Sigma, 64);

		len -= 512;
		iteration += 1;
	}

	memset(m, 0, 64);
	memcpy(m + 63 - len / 8 + ((len & 0x7) == 0), message, len / 8 + 1 - ((len & 0x7) == 0));

	// Stage 3
	app->stateMapper->setStep(App2::Step::STEP_3);

	m[63 - len / 8] |= (1 << (len & 0x7));

	g_N(N, hash, m);
	app->stateMapper->setValue(App2::Value::G_N, hash, 64);

	v512[63] = len & 0xFF;
	v512[62] = len >> 8;

	AddModulo512(N, v512, N);
	app->stateMapper->setValue(App2::Value::N, N, 64);

	AddModulo512(Sigma, m, Sigma);
	app->stateMapper->setValue(App2::Value::EPSILON, Sigma, 64);

	g_N(v0, hash, N);
	app->stateMapper->setValue(App2::Value::G_N, hash, 64);

	g_N(v0, hash, Sigma);
	app->stateMapper->setValue(App2::Value::G_N, hash, 64);

	memcpy(out, hash, 64);

	app->AddGOSTStep("S3_hash", hash, 64);
}

void Stribog::hash_512(const unsigned char *message, unsigned long long length, unsigned char *out)
{
	unsigned char IV[64] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	hash_X(IV, message, length, out);
}

void Stribog::hash_256(const unsigned char *message, unsigned long long length, unsigned char *out)
{
	unsigned char IV[64] =
	{
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
	};
	unsigned char hash[64];

	hash_X(IV, message, length, hash);

	memcpy(out, hash, 32);
}